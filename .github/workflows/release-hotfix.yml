name: release-hotfix
on:
  pull_request:
    types: [closed]

permissions:
  contents: write
  pull-requests: write
  issues: write

concurrency:
  group: release-${{ github.event.pull_request.number }}
  cancel-in-progress: false

jobs:
  release:
    name: Create Release
    if: >
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'main' &&
      (startsWith(github.event.pull_request.head.ref, 'release/') ||
       startsWith(github.event.pull_request.head.ref, 'hotfix/'))
    runs-on: ubuntu-latest
    outputs:
      released: ${{ steps.do_release.outputs.released }}
      tag: ${{ steps.do_release.outputs.tag }}
      headRef: ${{ steps.do_release.outputs.headRef }}
    steps:
      - id: do_release
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const headRef = pr.head.ref;

            const m = headRef.match(/^(?:release|hotfix)\/((0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-(?:0|[1-9]\d*|\d*[A-Za-z-][0-9A-Za-z-]*)(?:\.(?:0|[1-9]\d*|\d*[A-Za-z-][0-9A-Za-z-]*))*)?(?:\+[0-9A-Za-z-]+(?:\.[0-9A-Za-z-]+)*)?)$/);
            if (!m) core.setFailed('Branch name without valid SemVer: expected release/x.y.z[-pre][+build] or hotfix/x.y.z[-pre][+build]');
            const version = m[1];
            const tag = `v${version}`;
            const isPrerelease = version.includes('-');

            // Idempotency: abort if already exists
            let tagExists=false, relExists=false;
            try { await github.rest.git.getRef({ owner, repo, ref: `tags/${tag}` }); tagExists=true; } catch(e){ if (e.status !== 404) throw e; }
            try { await github.rest.repos.getReleaseByTag({ owner, repo, tag }); relExists=true; } catch(e){ if (e.status !== 404) throw e; }
            if (tagExists || relExists) {
              core.setFailed(`Tag/Release ${tag} already exists – workflow aborted.`);
              return;
            }

            await github.rest.repos.createRelease({
              owner, repo,
              tag_name: tag,
              target_commitish: pr.merge_commit_sha,
              name: tag,
              prerelease: isPrerelease,
              draft: false,
              generate_release_notes: true
            });

            core.setOutput('released', 'true');
            core.setOutput('tag', tag);
            core.setOutput('headRef', headRef);

  back-merge:
    name: Back-merge main -> develop
    needs: release
    if: ${{ needs.release.outputs.released == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const tag   = `${{ needs.release.outputs.tag }}`;
            const base  = 'develop';
            const head  = 'main';

            // 1) Direct merge attempt
            let mergedDirect = false;
            try {
              const r = await github.rest.repos.merge({
                owner, repo, base, head,
                commit_message: `Sync ${head} -> ${base} after ${tag}`
              });
              if (r.data.sha) { mergedDirect = true; core.info(`Direct back-merge: ${r.data.sha}`); }
            } catch (e) {
              core.info(`Direct merge not possible (${e.status}): ${e.message}`);
            }

            // 2) Fallback: create/merge PR
            if (!mergedDirect) {
              const list = await github.rest.pulls.list({ owner, repo, state: 'open', base, head: `${owner}:${head}` });
              let pr = list.data[0];
              if (!pr) {
                const created = await github.rest.pulls.create({
                  owner, repo, base, head,
                  title: `Sync ${head} -> ${base} after ${tag}`,
                  body: `Automatic back-merge after ${tag}.`
                });
                pr = created.data;
                try { await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ['back-merge'] }); } catch {}
              }
              try {
                await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: 'merge' });
                core.info(`Back-merge PR #${pr.number} merged.`);
              } catch (e) {
                core.info(`Back-merge PR #${pr.number} could not be merged (${e.status}).`);
                try {
                  const latest = await github.rest.pulls.get({ owner, repo, pull_number: pr.number });
                  if (latest.data.mergeable === false || latest.data.mergeable_state === 'dirty') {
                    await github.rest.issues.addLabels({ owner, repo, issue_number: pr.number, labels: ['needs-conflict-resolution'] });
                    await github.rest.issues.createComment({
                      owner, repo, issue_number: pr.number,
                      body: `Conflicts detected. Please resolve manually.`
                    });
                  }
                } catch {}
              }
            }

  cleanup:
    name: Delete release/hotfix branch
    needs: release
    if: ${{ needs.release.outputs.released == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const headRef = `${{ needs.release.outputs.headRef }}`;

            if (pr.head.repo.full_name !== `${owner}/${repo}`) {
              core.info('Branch from fork – deletion skipped.');
              return;
            }
            try {
              await github.rest.git.deleteRef({ owner, repo, ref: `heads/${headRef}` });
              core.info(`Branch deleted: ${headRef}`);
            } catch (e) {
              if (e.status === 422 || e.status === 404) core.info('Branch already deleted or not found.');
              else throw e;
            }
