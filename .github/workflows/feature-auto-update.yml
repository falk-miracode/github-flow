name: feature-auto-update

on:
  push:
    branches: [develop]
  schedule:
    - cron: "17 6 * * *" # daily 06:17 UTC
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: feature-auto-update
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Auto-update feature PRs with develop
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;

            // Ensure conflict label exists (best-effort)
            async function ensureLabel(name, color, description) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  try { await github.rest.issues.createLabel({ owner, repo, name, color, description }); } catch (_) {}
                }
              }
            }
            await ensureLabel('needs-conflict-resolution','B60205','Manual merge required for feature branch');

            // List candidates: feature/* PRs targeting develop; only same-repo heads (no forks)
            const prs = await github.paginate(github.rest.pulls.list, {
              owner, repo, state: 'open', base: 'develop', per_page: 100
            });

            const candidates = prs.filter(pr =>
              pr.head.ref.startsWith('feature/') &&
              pr.head.repo.full_name === `${owner}/${repo}`
            );

            core.info(`Open PRs to develop: ${prs.length}. Feature candidates: ${candidates.length}.`);
            if (candidates.length === 0) core.info('No feature PRs to update.');

            for (const pr of candidates) {
              core.info(`#${pr.number} (${pr.head.ref}): attempting "Update branch".`);

              let data;
              try {
                ({ data } = await github.rest.pulls.get({ owner, repo, pull_number: pr.number }));
              } catch (e) {
                core.warning(`#${pr.number}: cannot fetch PR details (HTTP ${e.status}) ${e.message}`);
                continue;
              }

              const tryUpdate = async (withSha) => {
                const params = { owner, repo, pull_number: pr.number };
                if (withSha) params.expected_head_sha = data.head.sha;
                return github.rest.pulls.updateBranch(params); // 202 Accepted on success
              };

              try {
                const res = await tryUpdate(true);
                core.info(`#${pr.number}: updateBranch accepted (HTTP ${res.status}).`);
              } catch (e) {
                const status = e.status || e.response?.status;
                const msg = e.response?.data?.message || e.message || '';
                if (status === 422 && /Expected head sha/i.test(msg)) {
                  const res2 = await tryUpdate(false);
                  core.info(`#${pr.number}: retried without expected_head_sha (HTTP ${res2.status}).`);
                } else if (status === 422 && /not required/i.test(msg)) {
                  core.info(`#${pr.number}: already up to date.`);
                } else if (status === 422 && /(conflict|merge conflict)/i.test(msg)) {
                  core.info(`#${pr.number}: merge conflict detected â€” labeling and commenting.`);
                  try {
                    await github.rest.issues.addLabels({
                      owner, repo, issue_number: pr.number, labels: ['needs-conflict-resolution']
                    });
                  } catch (e) {
                    core.warning(`#${pr.number}: failed to add 'needs-conflict-resolution' label: ${e.message}`);
                  }
                  try {
                    await github.rest.issues.createComment({
                      owner, repo, issue_number: pr.number,
                      body: `Automatic update failed due to merge conflicts between 'develop' and '${pr.head.ref}'.`
                    });
                  } catch (_) {}
                } else if (status === 403) {
                  core.warning(`#${pr.number}: insufficient permissions or branch protection prevented the update. Message: ${msg}`);
                } else {
                  core.warning(`#${pr.number}: updateBranch failed (HTTP ${status}) ${msg}`);
                }
              }
            }
